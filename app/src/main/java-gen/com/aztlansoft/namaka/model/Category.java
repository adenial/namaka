package com.aztlansoft.namaka.model;

import java.util.List;

import com.aztlansoft.namaka.dao.DaoSession;

import de.greenrobot.dao.DaoException;

import com.aztlansoft.namaka.dao.CategoryDao;
import com.aztlansoft.namaka.dao.DiscountDao;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 

/**
 * Entity mapped to table CATEGORY.
 */
public class Category
{

  private Long id;
  private String name;
  private String description;

  /**
   * Used to resolve relations
   */
  private transient DaoSession daoSession;

  /**
   * Used for active entity operations.
   */
  private transient CategoryDao myDao;

  private List<Discount> discounts;

  public Category()
  {
  }

  public Category(Long id)
  {
    this.id = id;
  }

  public Category(Long id, String name, String description)
  {
    this.id = id;
    this.name = name;
    this.description = description;
  }

  /**
   * called by internal mechanisms, do not call yourself.
   */
  public void __setDaoSession(DaoSession daoSession)
  {
    this.daoSession = daoSession;
    myDao = daoSession != null ? daoSession.getCategoryDao() : null;
  }

  public Long getId()
  {
    return id;
  }

  public void setId(Long id)
  {
    this.id = id;
  }

  public String getName()
  {
    return name;
  }

  public void setName(String name)
  {
    this.name = name;
  }

  public String getDescription()
  {
    return description;
  }

  public void setDescription(String description)
  {
    this.description = description;
  }

  /**
   * To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity.
   */
  public List<Discount> getDiscounts()
  {
    if (discounts == null)
    {
      if (daoSession == null)
      {
        throw new DaoException("Entity is detached from DAO context");
      }
      DiscountDao targetDao = daoSession.getDiscountDao();
      List<Discount> discountsNew = targetDao._queryCategory_Discounts(id);
      synchronized (this)
      {
        if (discounts == null)
        {
          discounts = discountsNew;
        }
      }
    }
    return discounts;
  }

  /**
   * Resets a to-many relationship, making the next get call to query for a fresh result.
   */
  public synchronized void resetDiscounts()
  {
    discounts = null;
  }

  /**
   * Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context.
   */
  public void delete()
  {
    if (myDao == null)
    {
      throw new DaoException("Entity is detached from DAO context");
    }
    myDao.delete(this);
  }

  /**
   * Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context.
   */
  public void update()
  {
    if (myDao == null)
    {
      throw new DaoException("Entity is detached from DAO context");
    }
    myDao.update(this);
  }

  /**
   * Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context.
   */
  public void refresh()
  {
    if (myDao == null)
    {
      throw new DaoException("Entity is detached from DAO context");
    }
    myDao.refresh(this);
  }

  @Override
  public String toString()
  {
    return this.name;
  }
}
